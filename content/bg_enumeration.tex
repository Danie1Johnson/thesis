\section{Known Enumerative Results}
--like polyominos
--Endres/Zlotnick
--Integer database
\section{New Enumerative Results}

As we consider polyhedra with more and more faces, there is a combinatorial explosion in the number intermediates in state space. While the 6-faced cube state space has only 8 nodes and 9 nodes, the 20-faced icosahedron state space has 2,649 nodes and 17,241 nodes and the 26-faced truncated cuboctahedron state space has 1,525,605 nodes and 17,672,377. Figure \ref{fig:bgtable} details state space sizes of all polyhedra in the Platonic, Archimedean, and Catalan solid classes of up to 26 faces. 


Also something about pathway statistics. 


\begin{figure}[ht]
%\scalebox{0.6}{
%{\footnotesize
\centering
%\textbf{Building Game Enumerative Results for the Platonic Solids}
\begin{tabular}{ l | c | r | r | r}
Polyhedra Name & $|F|$ & Intermediates & Connections & Pathways \\
  \hline    
Tetrahedron                     & 4        & 5     	& 4             & 1\\
Cube                            & 6        & 9     	& 10    	& 3\\
Octahedron                      & 8        & 15    	& 22    	& 14\\
Dodecahedron                    & 12       & 74    	& 264   	& 17,696 \\
Icosahedron                     & 20       & 2,650 	& 17,242        & 57,396,146,640\\
\end{tabular}
%}
\caption{Building game enumerative results for the Platonic solids.}
\label{tab:bgePlat}
\end{figure}


\begin{figure}[ht]
%\scalebox{0.6}{
%{\footnotesize
\centering
%\textbf{Building Game Enumerative Results for the Platonic Solids}
\begin{tabular}{ l | c | r | r | r}
Polyhedra Name & $|F|$ & Intermediates & Connections & Pathways \\
  \hline    
Truncated Tetrahedron           & 8        & 29    	& 65            & 402\\
Cuboctahedron                   & 14  	& 341   	& 1,636         & 10,170,968\\
Truncated Cube                  & 14  	& 500   	& 2,731         & 101,443,338 \\
Truncated Octahedron            & 14  	& 556           & 3,071         & 68,106,377\\
Rhombicuboctahedron             & 26  	& 638,851       & 6,459,804     & 16,494,392,631,838,879,380\\
Truncated Cuboctahedron         & 26  	& 1,525,605     & 17,672,377    & ? \\
Icosidodecahedron               & 32  	& ?             & ?             & ?\\
Truncated Dodecahedron          & 32  	& ?             & ? 	        & ? \\
Truncated Icosahedron           & 32  	& ?             & ? 	        & ?\\
\end{tabular}
%}
\caption{Building game enumerative results for the Archimedean solids.}
\label{tab:bgeArch}
\end{figure}


\begin{figure}[ht]
%\scalebox{0.6}{
%{\footnotesize
\centering
%\textbf{Building Game Enumerative Results for the Platonic Solids}
\begin{tabular}{ l | c | r | r | r}
Polyhedra Name & $|F|$ & Intermediates & Connections & Pathways \\
  \hline    
Triakis Tetrahedron             & 12       & 99            & 319           & 38,938\\
Rhombic Dodecahedron            & 12  	& 128           & 494           & 76,936\\
Triakis Octahedron              & 24  	& 12,749        & 81,297        & 169,402,670,046,670\\
Tetrakis Hexahedron             & 24  	& 50,768        & 394,278       & 4,253,948,297,210,346\\
Deltoidal Icositetrahedron      & 24  	& 209,676       & 1,989,549     & ? \\
Pentagonal Icositetrahedron     & 24  	& 345,939       & 3,544,988     & 2,828,128,000,716,774,492\\
Rhombic Triacontahedron         & 30  	& ?             & ?             & 5,266,831,101,345,821,968\\
\end{tabular}
%}
\caption{Building game enumerative results for the Catalan solids.}
\label{tab:bgeCat}
\end{figure}



\subsection{Shellability}
Ziegler provides the following definitions of a shelling and a shellable polytopal complex. 
\begin{mydef}
Let $\mathcal{C}$ be a pure $k$-dimensional polytopal complex $\mathcal{C}$. A shelling of $\mathcal{C}$ is a linear ordering $F_1,F_2,\dots,F_s$ of the facets of $\mathcal{C}$ such that either $\mathcal{C}$ is $0$-dimensional (and thus the facets are points), or it satisfies the following conditions:
\begin{enumerate}[(i)]
\item The boundary complex of the first facet $F_1$ has a shelling.
\item For $1 < j \leq s$ the intersection of the facet $F_j$ with the previous facets is non empty and is a beginning segment of a shelling of the $(k-1$-dimensional boundary complex of $F_j$, that is,
$$F_j \cap \left(\bigcup_{i=1}^{j-1}F_i\right) = G_1 \cup G_2 \cup \cdots \cup G_r$$
for some shelling $G_1, G_2, \dots, G_r, \dots, G_t$ of $\mathcal{C}(\partial F_j)$, and $1 \leq r \leq t$. (In particular, this requires that $F_j \cap (\bigcup_{i=1}^{j-1} F_i)$ has a shelling, so it has to be a pure $(k-1)$-dimensional, and connected for $k > 1$.)
\end{enumerate} 
\textbf{shelling}
\end{mydef}




\begin{figure}[ht]
%\scalebox{0.6}{
\centering
%\textbf{Building Game Enumerative Results for the Platonic Solids}
\begin{tabular}{ l | c | r | r | r}
Polyhedra Name & $|F|$ & Intermediates & Connections & Pathways \\
  \hline    
Tetrahedron                     & 4     & 5     & 4 	& 1\\
Cube                            & 6     & 8     & 8 	& 2\\
Octahedron                      & 8     & 12    & 12 	& 14 \\
Dodecahedron                    & 12    & 53    & 156 	& 2166\\
Icosahedron                     & 20    & 468   & 1984 	& 105999738\\
\end{tabular}
%}
\caption{Building game enumerative shellability results for the Platonic solids.}
\label{tab:bgeCat}
\end{figure}

\begin{figure}[ht]
%\scalebox{0.6}{
\centering
%\textbf{Building Game Enumerative Results for the Platonic Solids}
\begin{tabular}{ l | c | r | r | r}
Polyhedra Name & $|F|$ & Intermediates & Connections & Pathways \\
  \hline    
Truncated Tetrahedron           & 8     & 22	& 42 		& 174\\
Cuboctahedron                   & 14	& 137	& 470 		& 477776\\
Truncated Cube                  & 14	& 248	& 1002 		& 5232294\\
Truncated Octahedron            & 14	& 343	& 1466 		& 5704138\\
Rhombicuboctahedron             & 26	& 70836	& 462149 	& 48399693494788840\\
Truncated Cuboctahedron         & 26	& ?	& ? 		& ?\\
Icosidodecahedron               & 32	& ?	& ? 		& ?\\
Truncated Dodecahedron          & 32	& ?	& ? 		& ?\\
Truncated Icosahedron           & 32	& ?	& ? 		& ?\\
\end{tabular}
%}
\caption{Building game enumerative shellability results for the Archimedean solids.}
\label{tab:bgeCat}
\end{figure}

\begin{figure}[ht]
%\scalebox{0.6}{
\centering
%\textbf{Building Game Enumerative Results for the Platonic Solids}
\begin{tabular}{ l | c | r | r | r}
Polyhedra Name & $|F|$ & Intermediates & Connections & Pathways \\
  \hline    
Triakis Tetrahedron             & 12    & 49	& 116 		& 5012\\
Rhombic Dodecahedron            & 12 	& 68	& 196 		& 6258\\
Triakis Octahedron              & 24	& 667	& 2383 		& 15255459\\
Tetrakis Hexahedron             & 24	& 4220	& 21079 	& 5854799360107\\
Deltoidal Icositetrahedron      & 24	& ?	& ? 		& ?\\
Pentagonal Icositetrahedron     & 24	& 95127	& 654537 	& 5607231936129109\\
Rhombic Triacontahedron         & 30	& 97368	& 697623 	& 6889989896241902854\\
\end{tabular}
%}
\caption{Building game enumerative shellability results for the Catalan solids.}
\label{tab:bgeCat}
\end{figure}

\subsection{Bounds and Asymptotics}
There is a clear relation between the number of faces in a polyhedron and then number of intermediates it has. However, that relationship also greatly depends on the polyhedral symmetry group. For instance, if you have a polyhedron with a small number of faces and a trivial rotation group consisting only of the identity, every edge-connected subset of the polyhedron's faces will be a distinct intermediate. In agregate, this may mean that the polyhedron has more intermediates than another polyhedron with more faces, yet a larger symmetry group. 

An upper bound on the number of intermediates is possible using the theory of group actions. Consider the set of all subsets $2^F$ of a polyhedron with rotation group $G$. Trivially $|2^F/G|$ is an upper bound on the number of intermediates since it simply relaxes the connectivity requirement for a subset to be a building game state. Using Burnside's lemma, we see that 
\begin{align}
  \label{eq:IntUB}
  |2^F/G| &= \frac{1}{|G|}\sum_{g \in G}|(2^F)^g| \\
  &> \frac{|(2^F)^e|}{|G|} \\
  &= \frac{|2^F|}{|G|} \\
  &= \frac{2^{|F|}}{|G|}
\end{align}
which is not a particularly good bound in practice. The exact value of $|2^F/G|$ is calcuable with minimal computer assistance. For the cube, the bound is fairly tight, only including the two non-intermediates corresponding to the empty subset of faces, and the non-connected subset consisting of the top and bottom faces. Thus the cube has the bound $|2^F/G| = 10 \geq 8$. In the case of the tetrahedron, the only overcounted subset of faces is the empty one and the bound is $|2^F/G| = 5 \geq 4$. However, in the case of the icosahedron we have $|2^F/G| \geq \frac{2^{20}}{60} \approx 17476.3 \gg 2649$. Here we use the approximate bound $\frac{2^{|F|}}{|G|}$ which is the largely dominant term in the sum from equation~\ref{eq:IntUB}.

We can get a similar bound on the number of intermediates with a particular number of faces,
\begin{align}
  |\{x \in 2^F: |x| = k\} /G| &= \frac{1}{|G|}\sum_{g \in G}|\{x \in 2^F: |x| = k\}^g| \\
  &> \frac{|\{x \in 2^F: |x| = k\}^e|}{|G|} \\
  &= \frac{|\{x \in 2^F: |x| = k\}|}{|G|} \\
  &= \frac{{|F| \choose k}}{|G|}
\end{align}
but again, this is not particularly useful, especially for intermediates with $\sim\frac{|F|}{2}$ faces.

Since the building game is similar in spirit to polyomino enumeration, one might try to assimilate some the techniques used for polyominos. For example, through fairly simple arguments, one can show that $s_ms_n \leq s_{m+n}$ where $s_m$ is the number of unique polyominos with $m$ subunits CITE. This leads to the bound $s_m \leq (const)^m$. Trying to set up such a relation in the building game is sounds initially appealing, but there is a fundamental diefference between the two growth models that makes this approach futile. In the polyomino case, there is no limit to the number of subunits that can be considered. Importantly, this is not the case for the bulding game since an intermediate can only have $|F|$ faces at most. Thus any such reccurrence relation for the building game will result in a good upper bound for the intermediates with a small number of faces at best.

The formulation of meaningful bounds for the number of building game intermediates with $k$ faces remains an open problem, especially for $k \sim \frac{1}{2}|F|$. At the root of the problem is the difficulty in mathematicallly describing the subsets of $F$ are edge connected. Future approches may incorperate enumeration results for connected subgraphs or Hamiltonian paths since these topics explicitly acknowledge connectedness properties. 

From looking at the statistics on number of faces $|F|$ of a polyhedron and the number of intermediates in its commbintorial configuration space, it is natural to want to make statements about the asymptotic growth of thr combinatorial configuration space's size. Unfortunately, when formed in this way, the problem is ill-posed. To discuss assymptotics, we must first specify an infinite class of polyhedra. The Platonic, Archimedean, and Catalan Solid classes that we've worked with thus far are all finite though, so other choices must be consider. One option is to take an existing polyhedron in one of these classes and create an infinite family by describing finer and finer tiling on top of the polyhedron's faces. If designed cafefully each member of the tiled polyhedron family will have the same symmetry group, even as the number of faces grows. 

Similar to polyhedra with tiled faces are the icosahedron viral capsids indexed by T-number. This number is related to the number of protein subunits in the virust. When each subunit is idealized as a polygon, a T-capsid will consist of $12$ pentagons and $10(T-1)$ hexagons. Interestingly, this makes most of the icosahedral viral capsid equivalent to the dual of an icosahedron with each face consisting of $T$ trianglular tiles. This would certainly be an interesting an relevant familty of polyhedra to consider, though we leave it as an opn problem.

\section{Computational Methods}

To compute the combinatorial configuration space and enumerate the intermediates for a particular polyhedron, we use a brute force method. Computation begins with first enumerating the intermediates with a single face. This enumeration is then used to compute the intermediates with two faces. This process proceeds iteratively until all intermediates are accounted for. Figure~\ref{alg:CCS} outlines the detailed algorithm for this computation. 

At each stage of our algorith, we know the set of intermedites that have $k$ faces, which we call $A_k$, and use this information to compute the set of faces with $k+1$ faces, $A_{k+1}$. Since all intermediates in $A_{k+1}$ must be formed by adding a single face to an intermediate from $A_k$, we take each intermediate $[x] \in A_k$ and try adding each face to $x$ that is allowable under the building game rules. This means we look at every face $f \in F$ and check if $f \not\in x$ and also that $x$ is edge connected to a face $\hat{f}$ that is in $x$. For every such faces $f$, we look at the new $(k+1)$-faced state $y \doteq x\cup \{f\}$. Since we know that $[y]$ is a building game intermediate, it must be represented in $A_{k+1}$, however before adding $y$ to $A_{k+1}$, we must verify that there is no $\hat{y}$ already in $A_{k+1}$ such that $y \in [\hat{y}]$.

\begin{figure}[ht]
\centering
\begin{algorithmic}
  \State $A_0 \gets \{\emptyset\}$ 
  \State $A_1, \dots, A_{|F|} \gets \{\}$ 
  \For{$k = 0,\dots,|F|-1$}
  \For{$x \in A_k$ }
  \For{$f \in F\setminus x$ such that $\exists \hat{f} \in x$ with $f$ and $\hat{f}$ sharing an edge. }
  \State NewIntermediate $\gets True$
  \For{$\hat{y} \in A_{k+1}$}
  \If{$y \in [\hat{y}]$}
  \State NewIntermediate $\gets False$
  \State Add connection $[x] \leftrightarrow [\hat{y}]$ to combinatorial configuration space.
  \EndIf
  \EndFor
  \If{NewIntermediate $= True$}
  \State $A_{k+1} \gets A_{k+1} \cup \{y\}$
  \State Add connection $[x] \leftrightarrow [y]$ to combinatorial configuration space.
  \EndIf
  \EndFor
  \EndFor
  \EndFor
\end{algorithmic}
\caption{Algorithm for interatively enumerating the Building Game combinatorial configuration space.}
\label{alg:CCS}
\end{figure}

The act of comparing two states $y$ and $\hat{y}$ to check if they are members of the same intrmediate is the task where the majority of computational time is spent. The brute force method of checking if $y \sim \hat{y}$ involves checking if $g.y = \hat{y}$ for each $g \in G$. If a $g$ is found that makes this equality hold, then $[y] = [ \hat{y}]$ and the computation terminates and we know that $[y]$ is not a new intermediate. In this case, nothing is added to $A_{k+1}$ but a connection $x \leftrightarrow \hat{y}$ is added in the combinatorial configuration space. Furthermore, by tracking how many time a particular connection $x \leftrightarrow \hat{y}$ is found, the forward degeneracy numbers can be computed. 

\subsection{Hash Functions}
In practice, we implement a hash function $\textswab{h}$ that maps each state to an integer with the property that if $[y] = [\hat{y}]$, then $\textswab{h}(y) = \textswab{h}(\hat{y})$. If we can design such a function and it is computable in significantly less time relative to the brute force method of trying every rotation, the overall computation can be majorly diminished. 

When checking if two states $y$ and $\hat{y}$ are members of the same intermediate, we first check if $\textswab{h}(y) = \textswab{h}(\hat{y})$. If they do not have the same hash, then they cannot be members of the same intermediate and the check is complete. Alternatively, if they do have identical hashes, it is not a guarentee that they are members of the same intermediate, so the brute force rotation method must be used. If the hash is carefully designed then this false positive rate ($\textswab{h}(y) = \textswab{h}(\hat{y})$ when $[y] \neq [\hat{y}]$) is small and almost all of the brute force calculations will result in a positive match. 

In an ideal world, a hash function that also gives the property $[x] = [\hat{x}]$ whenever $\textswab{h}(x) = \textswab{h}(\hat{x})$ would be best. However we have not been able to find such an $\textswab{h}$ that is computable in a relatively reduced amount of time in comparison to the brute force method. We leave the existance of such a hash as a possibility. 

Since any hash we choose must a function that maps states that are rotations of each other to the same integer, we look at local connectivity properties. For each face $f_k \in F$ define its local connectivity within $y$ as  $\textswab{h}_k(y) = |\{\hat{f} \in F : \hat{f} \in y, f_k \cap \hat{f} \in E\}|$, the number of faces adjacent to $f_k$ that are in $y$. Since this connectivity is preserved by rotations, even though we wont necesarily have $\textswab{h}_k(y) = \textswab{h}_k(\hat{y})$ when $[y] = [\hat{y}]$, if we take a histogram of all values of $\textswab{h}_k$ for $k = 1,\dots,|F|$, the histogram will be the same for both $y$ and $\hat{y}$. Once a histogram is computed, the final hash $\textswab{h}$ is just a simple function that maps histograms to integers.

There are many variants of statistics that this histogram strategy can be used with. We found that taking separate histograms for faces in $y$ and faces not in $y$ provided a hash with less false positives, while only increasing the hash computation time marginally. Depending on the polyhedron, the implementation of this hash lead to an over all speed up of at least an order of magnitude over the purely brute force method.  

\subsection{Data Structures}

Before the computation of the combinatorial configuration space, we hardcode an enumeration $f_1, \dots, f_{|F|}$ of the faces of our polyhedron. Then, any state $x$ is represented by a binary vector of length $|F|$ with a one in the $k$th entry if $f_k \in x$ and zero otherwise. With this convention, each rotation $g \in G$ corresponds to a permutation of the indices of $x$. Each such permutation in the group is precomputed and then applies as necessary when performing a brute force comparison of two states. To track the connectivity structure of the polyhedron, an adjaceny list on faces is stored as a two dimensional array. For each face number, the adjacency list specifies the index of adjacent faces.

Each group of $k$-faced intermediates $A_k$ is stored as a hash table using the previously described hash function. This allows for order one lookup of intermediates already in the $A_k$ that share the hash of a new proposal intermediate. 

